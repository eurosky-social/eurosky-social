apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: ${cluster_name}
  namespace: ${namespace}
spec:
  instances: 2 # TODO: Increase to 3 for production HA (requires 3 availability zones)

  imageName: ghcr.io/cloudnative-pg/postgresql:16.6 # TODO: Pin to specific digest for immutability

  storage:
    storageClass: ${storage_class}
    size: 20Gi

  primaryUpdateStrategy: unsupervised

  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: topology.kubernetes.io/zone
      whenUnsatisfiable: DoNotSchedule
      labelSelector:
        matchLabels:
          cnpg.io/cluster: ${cluster_name}

  affinity:
    podAntiAffinityType: required
    topologyKey: kubernetes.io/hostname

  backup:
    target: primary
    retentionPolicy: "30d" # TODO: Adjust retention based on compliance requirements

  postgresql:
    parameters:
      max_connections: "100" # TODO: Tune based on expected connection pool size and workload
      shared_buffers: "128MB" # TODO: Adjust based on available memory (typically 25% of RAM)
      effective_cache_size: "512MB" # TODO: Set to ~75% of available memory
      work_mem: "2MB" # TODO: Calculate based on max_connections and query complexity
      wal_compression: "on"
      archive_timeout: "${archive_timeout}"

  plugins:
    - name: barman-cloud.cloudnative-pg.io
      isWALArchiver: true
      parameters:
        barmanObjectName: ${backup_objectstore_name}
        serverName: ${cluster_name} 

  monitoring:
    enablePodMonitor: true

  managed:
    roles:
      - name: ozone_user
        ensure: present
        login: true
        passwordSecret:
          name: ozone-db-secret

  bootstrap:
%{ if !enable_recovery ~}
    initdb:
      database: postgres
      owner: postgres
      dataChecksums: true
      postInitApplicationSQL:
        - CREATE DATABASE ozone OWNER ozone_user;
        - ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO ozone_user;
        - ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO ozone_user;
%{ else ~}
    recovery:
      source: postgres-backup-recovery

  externalClusters:
    - name: postgres-backup-recovery
      plugin:
        name: barman-cloud.cloudnative-pg.io
        parameters:
          barmanObjectName: ${backup_objectstore_name}
          serverName: ${recovery_source_cluster_name}
%{ endif ~}

  resources: # TODO: Right-size based on actual workload metrics and load testing
    requests:
      memory: "256Mi" # TODO: Ensure requests align with shared_buffers + work_mem calculations
      cpu: "100m"
    limits:
      memory: "512Mi" # TODO: Set memory limit 2x shared_buffers to avoid OOM kills
      cpu: "500m" # TODO: Consider removing CPU limits to avoid throttling in production
